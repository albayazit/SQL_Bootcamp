# SQL BOOTCAMP

**Database: PostgreSQL**
### SELECT
* SELECT - указывает на то, что мы хотим выбрать
* SELECT DISTINCT - выбирает уникальные значения
  
Внутренний запрос позволяет извлечь необходимые данные для внешнего запроса:
```
SELECT
	(SELECT name FROM person WHERE person.id = o.person_id)
AS NAME
```

**||** (или CONCAT) - оператор конкатенации строк. Используется для объединения значений столбцов и строковых литералов.
```
SELECT name || ' age:' || age || 
```
Для добавления ковычек необходимо экранирововать их: `''''`
### FROM
* FROM - указывает таблицу
Можно сокращать названия столбцов (через пробел новые имена):
```
FROM person_order o
```
### WHERE
* WHERE - указываются условия выбора
### ORDER
* ORDER BY - сортирует в алфавитном порядке
* ORDER BY ... DESC - сортирует в порядке убывания
* ORDER BY ... ASC - сортирует в порядке возростания

### JOIN
Соединение — это операция между двумя таблицами. Для понимания этой операции можно представить псевдокод, показывающий, как работает соединение без использования индексов:
```
FOR r in R LOOP
    FOR s in S LOOP
        if r.id = s.r_id then add(r,s)
        …
    END;
END;
```
- JOIN - соединяет две таблицы на основе общих столбцов
- NATURAL JOIN - автоматический соединяет все столбцы таблиц, на основе столбцов с общими названиями
- RIGHT JOIN (или RIGHT OUTER JOIN) соединяет две таблицы и возвращает все записи из правой таблицы (таблицы, указанной после RIGHT JOIN), даже если нет соответствующих записей в левой таблице. Если совпадение не найдено, соответствующие столбцы из левой таблицы заполняются NULL.
- LEFT JOIN то же самое что и RIGHT JOIN, но наоборот.
- CROSS JOIN возвращает декартово произведение двух таблиц, то есть каждая строка из первой таблицы соединяется с каждой строкой из второй таблицы. Результатом будет количество строк первой таблицы, умноженное на количество строк второй таблицы.
- FULL JOIN (или FULL OUTER JOIN) — это тип соединения в SQL, который объединяет результаты как LEFT JOIN, так и RIGHT JOIN. Он возвращает все строки из обеих таблиц, независимо от того, есть ли совпадение по условию соединения.
- Theta Join Использует произвольное условие соединения, а не только равенство.
- Semi Join Возвращает строки из первой таблицы, которые имеют соответствие во второй таблице, но не включает данные из второй таблицы.
- Anti Join Возвращает строки из первой таблицы, которые не имеют соответствия во второй таблице.

### EXIST, NOT IN
- EXIST - проверяет, возвращает ли подзапрос какие либо строки.
- NOT IN - проверяет, есть ли строка в подзапросе

### CASE
* CASE WHEN ... THEN ... ELSE ... END AS- вычисляет новый столбец, проверяя условие
```
SELECT
	(SELECT name FROM person WHERE person.id = o.person_id)
AS NAME,
	CASE WHEN (SELECT name FROM person WHERE person.id = o.person_id) = 'Denis' THEN true ELSE false END AS check_name
```

### CONSTANTS
* ... AND ... / ... OR ... - логические опреаторы И / ИЛИ
* BETWEEN - выборка между двумя значениями
* ... AS - назначает имя новому вычисляемому полю
* ... * - выбрать все

Можно использовать операторы сравнения (>, <, =, ...).
При этом, следует использовать скобки для выделения блоков.
```
WHERE (visit_date BETWEEN '2022-01-06' AND '2022-01-09')
	OR pizzeria_id = 2
```
### SETS

В реляционных базах данных множества (sets) используются для выполнения различных операций с результатами запросов. Эти операции позволяют объединять, вычитать и находить пересечения между наборами данных. Основные операторы множеств в SQL включают:

	1.	UNION [ALL]
	2.	EXCEPT [ALL]
	3.	INTERSECT [ALL]

Операторы множеств
	1.	UNION [ALL]
	•	UNION объединяет результаты двух или более запросов, исключая дубликаты.
	•	UNION ALL объединяет результаты двух или более запросов, включая дубликаты.
	2.	EXCEPT [ALL]
	•	EXCEPT возвращает строки из первого запроса, которые отсутствуют во втором запросе, исключая дубликаты.
	•	EXCEPT ALL возвращает строки из первого запроса, которые отсутствуют во втором запросе, включая дубликаты.
	3.	INTERSECT [ALL]
	•	INTERSECT возвращает строки, присутствующие в обоих запросах, исключая дубликаты.
	•	INTERSECT ALL возвращает строки, присутствующие в обоих запросах, включая дубликаты.

Основные правила работы с операторами множеств

	1.	Соответствие атрибутов: Количество и типы столбцов в запросах, объединяемых с помощью операторов множеств, должны совпадать.
	2.	Имена атрибутов: Имена столбцов в результирующем наборе данных определяются именами столбцов из первого запроса.

### Recursive

Рекурсивные запросы позволяют выполнять итеративные операции над данными, такие как работа с иерархическими структурами (например, организационными структурами, деревьями каталогов).

В PostgreSQL рекурсивные запросы создаются с использованием конструкции WITH RECURSIVE.

```
WITH RECURSIVE subordinates AS (
    SELECT employee_id, manager_id, name, 1 AS level
    FROM employees
    WHERE manager_id IS NULL -- Начальный запрос

    UNION ALL

    SELECT e.employee_id, e.manager_id, e.name, s.level + 1
    FROM employees e
    INNER JOIN subordinates s ON s.employee_id = e.manager_id -- Рекурсивный запрос
)
SELECT * FROM subordinates;
```

### Применение SQL множеств
SQL множества также полезны для вычисления различных метрик, таких как расстояние Жаккара между двумя объектами. Расстояние Жаккара измеряет сходство между двумя наборами данных.

Формула для вычисления коэффициента Жаккара:
`J(A, B) = |A x B| / |A + B|`

### Relational Expression
Любой SQL-запрос можно описать на математическом языке реляционной алгебры. Возникает вопрос: зачем изучать реляционную алгебру, если можно сразу писать запросы на SQL? Ответить на этот вопрос можно двояко: «Да» и «Нет».

	•	«Да», потому что вы действительно можете сразу написать запрос на SQL, если вы уже знаете синтаксис.
	•	«Нет», потому что знание реляционной алгебры важно для понимания ключевых аспектов, которые используются при планировании оптимизации запросов и при создании семантических запросов.

### Date
Операция ::date в SQL (в частности, в PostgreSQL) используется для приведения данных к типу date. Она является оператором приведения типа, который позволяет явно преобразовать значение в указанный тип данных.
`SELECT '2022-01-01'::date;`

### Functions
Функция generate_series(...) в PostgreSQL используется для создания ряда значений. Эта функция особенно полезна для генерации последовательностей чисел, дат или временных интервалов.
`generate_series(start, stop, step)`


CTE (Common Table Expression), или Общие Табличные Выражения, — это конструкция в SQL, которая позволяет определять временные результаты, которые могут быть использованы в последующих запросах. CTE создаются с использованием ключевого слова WITH и могут значительно упростить написание и понимание сложных SQL-запросов.

```
WITH cte_name AS (
    SELECT column1, column2, ...
    FROM table_name
    WHERE conditions
)
SELECT column1, column2, ...
FROM cte_name
WHERE other_conditions;
```


GROUP BY — это ключевое слово в SQL, которое используется для группировки строк, которые имеют одинаковые значения в указанных столбцах, и выполнения агрегатных функций, таких как COUNT(), SUM(), AVG(), MAX(), MIN() и другие, для каждой группы отдельно.

### INSERT
INSERT позволяет добавлять нвоые стркои в базу данных.
```
INSERT INTO table(id, ...)
VALUES ()
```
```
INSERT INTO table(id, ...)
SELECT ()
```

### DELETE
DELETE позволяет удалять строки из базы данных
```
DELETE FROM person_order
WHERE
```

### UPDATE
UPDATE позволяет обновлять существующие строки в базе данных
```
UPDATE menu
SET price = 1
WHERE price_id = 1
```


### VIEWS
В реляционной базе данных существует особый архитектурный шаблон, называемый ANSI/SPARK. Этот шаблон делит объекты на три уровня:
внешний уровень,
концептуальный уровень,
внутренний уровень.
#### VIEW
	1.	Определение: VIEW — это виртуальная таблица, которая не хранит данные. Она представляет собой результат запроса к одной или нескольким таблицам.
	2.	Динамичность: Данные в VIEW всегда актуальны, так как запрос выполняется каждый раз при обращении к VIEW. Это означает, что если исходные таблицы обновляются, изменения будут видны в VIEW сразу же.
	3.	Производительность: Так как данные не сохраняются, при каждом обращении к VIEW может происходить вычисление запроса, что может привести к снижению производительности, особенно если запрос сложный или работает с большим объемом данных.
	4.	Использование: VIEW подходит, когда необходимо часто использовать один и тот же запрос, который объединяет или фильтрует данные из нескольких таблиц, и когда важна актуальность данных.

#### MATERIALIZED VIEW
	1.	Определение: MATERIALIZED VIEW — это также виртуальная таблица, но в отличие от обычного VIEW, она хранит данные на диске. Это значит, что результат запроса сохраняется, и его можно использовать повторно.
	2.	Статичность: Данные в MATERIALIZED VIEW не обновляются автоматически. Для обновления данных нужно использовать специальную команду (например, REFRESH MATERIALIZED VIEW), чтобы перезагрузить данные из исходных таблиц.
	3.	Производительность: Поскольку данные сохраняются, запросы к MATERIALIZED VIEW выполняются быстрее, чем к VIEW, особенно если источник данных большой или сложный. Это особенно полезно для отчетов или аналитики, где важно быстро получать доступ к данным.
	4.	Использование: MATERIALIZED VIEW подходит, когда данные обновляются нечасто и необходимо ускорить выполнение запросов, которые основаны на сложных вычислениях или агрегатах.

```
CREATE (MATERIALIZED) VIEW <name> AS
SELECT ...
```
### DDL/DML
DDL (Data Definition Language) и DML (Data Manipulation Language) — это два типа SQL-запросов, которые выполняют разные задачи при работе с базами данных.

1. DDL (Data Definition Language)

DDL используется для определения и изменения структуры базы данных, включая создание, изменение и удаление объектов базы данных, таких как таблицы, индексы, схемы и т. д. DDL-команды влияют на структуру базы данных, но не на данные, которые она содержит.
2. DML (Data Manipulation Language)

DML используется для работы с данными, уже хранящимися в базе данных. Это включает вставку новых данных, обновление существующих данных, удаление данных и выборку данных.

### Functions
#### CONCAT
CONCAT — это функция в SQL, которая используется для объединения (конкатенации) двух или более строк в одну строку. Она соединяет значения строковых аргументов в порядке их следования.
`CONCAT(string1, string2, ..., stringN)`

#### Position
Функция POSITION в PostgreSQL используется для поиска местоположения подстроки в строке. Она возвращает индекс (позицию) первого вхождения подстроки. Если подстрока не найдена, возвращается 0.

`POSITION(substring IN string)`

### Indexes
BTree (сокращение от “Balanced Tree”) индексы — это тип индексов, который используется в реляционных базах данных для ускорения поиска данных. Этот тип индексов построен на основе сбалансированного дерева, что означает, что все листья дерева находятся на одном уровне, и операции поиска, вставки и удаления данных в таком дереве выполняются за логарифмическое время по количеству элементов.

### Anomalies
Аномалии:
“потерянное обновление”, где изменения, сделанные в одной транзакции, могут быть потеряны из-за конкуренции за изменение данных.
1. Аномалии в данных
2. Проблемы с производительностью (deadlock)
3. Аномалии транзакций
4. Конфигурационные аномалии

Уровни изоляции:
1. Read Uncommitted (Чтение неподтвержденных данных) - Этот уровень изоляции позволяет транзакции читать данные, которые были изменены другой транзакцией, но еще не были зафиксированы (committed). Это самый низкий уровень изоляции.
2. Read Committed (Чтение подтвержденных данных) - Наиболее используемый уровень изоляции. Транзакция видит только те данные, которые были зафиксированы на момент начала операции чтения.
3. Repeatable Read (Повторяемое чтение) - Транзакция видит данные в том состоянии, в котором они были на момент начала транзакции. Даже если другая транзакция изменит эти данные и зафиксирует изменения, текущая транзакция не увидит этих изменений.
4. Serializable (Сериализуемость) - Самый строгий уровень изоляции, где транзакции выполняются так, как если бы они выполнялись последовательно, одна за другой. Этот уровень предотвращает все виды аномалий, в том числе и фантомные чтения.